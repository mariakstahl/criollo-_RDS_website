[["index.html", "Reproducible Data Science Final Project 2023 Chapter 1 Project description 1.1 Datasets available 1.2 Database structure", " Reproducible Data Science Final Project 2023 Maria Stahl 2023-04-24 Chapter 1 Project description For my dissertation, I am following a herd of 40 cows in San Juan County, UT. 20 of these individuals are Red Angus, a conventional breed of cattle, and 20 are Raramuri Criollo, a heritage breed of cattle from the mountains of northern Mexico. Previous research suggests that Criollo cows may be better adapted to hot and dry desert conditions, making them a more sustainable alternative to Red Angus that would allow producers to maintain ecosystem function and health under livestock production. 1.1 Datasets available As part of this project, I am linking together many datasets into one relational database. Each cow as been equipped with GPS collars to track movement, and we have periodically collected morphometric data and fecal samples from the herd. Below are the datasets I have available and am adding to the database: Cow breed and ear tag ID Beef metrics (including weights and body condition scores) Diet sample data Collar deployment dates Collars (including brand and serial number) GPS data (raw from the collars) 1.2 Database structure Below is a schematic of the structure of my relational database. Chapter 3 will detail how the database was constructed. "],["combine-collar-data-from-lotek-and-ats-collars.html", "Chapter 2 Combine collar data from Lotek and ATS collars 2.1 Description 2.2 Read Lotek collar data 2.3 Read ATS data 2.4 Combine collar data 2.5 add cow ear tag and breed info 2.6 clean collar data 2.7 save output to .csv", " Chapter 2 Combine collar data from Lotek and ATS collars 2.1 Description We use two brands of collars for my project, ATS and Lotek. Each brand of collar has a slightly different spreadsheet output, so this code is needed to clean and combine the data from ATS and Lotek collars. This code reads in all the Lotek and ATS GPS .csv files, organizes them into the same format, and combines them into one .csv with the associated cow metadata (ear tag and breed). We need to do this before we create the database! Jan 2023: Lotek GPS files are matched with cattle ID based only on collar ID. This will be an issue in the future when we start re-using Lotek collars and have multiple cattle IDs associated with each Lotek collar. When this happens, I will need to add a section of code that looks not only at the collar ID but also at the dates to match collars to cows. 2.2 Read Lotek collar data # gps file names lotek.collar.files.march = list.files(path = &quot;../cattle/raw data/collar data/2022-03_collarData/gps&quot;, pattern = &quot;*.csv&quot;, full.names = T) lotek.collar.files.june = list.files(path = &quot;../cattle/raw data/collar data/2022-06_collarData/gps&quot;, pattern = &quot;*.csv&quot;, full.names = T) lotek.collar.files.all = c(lotek.collar.files.march, lotek.collar.files.june) # collar numbers lotek.collar.numbers = lotek.collar.files.all %&gt;% substring(nchar(.)-28, nchar(.)-24) # collar data lotek.collar.list = lotek.collar.files.all %&gt;% map(~fread(.)) # add column with collar number for(i in seq_along(lotek.collar.list)){ lotek.collar.list[[i]]$CollarSerialNumber &lt;- lotek.collar.numbers[i] } cattle.dat.lotek = lotek.collar.list %&gt;% bind_rows() 2.3 Read ATS data # gps file names ats.files = list.files(path = &quot;../cattle/raw data/collar data/ats&quot;, pattern = &quot;*.txt&quot;, full.names = T) # collar data ats.collar.list = ats.files %&gt;% map(~fread(.)) # create data.frame from list cattle.dat.ATS = ats.collar.list %&gt;% bind_rows() 2.4 Combine collar data # what column names are we working with here? names(cattle.dat.ATS) ## [1] &quot;CollarSerialNumber&quot; &quot;Year&quot; &quot;Julianday&quot; ## [4] &quot;Hour&quot; &quot;Minute&quot; &quot;Activity&quot; ## [7] &quot;Temperature&quot; &quot;Latitude&quot; &quot;Longitude&quot; ## [10] &quot;HDOP&quot; &quot;NumSats&quot; &quot;FixTime&quot; ## [13] &quot;2D/3D&quot; &quot;Date&quot; names(cattle.dat.lotek) ## [1] &quot;GMT Time&quot; &quot;Latitude&quot; &quot;Longitude&quot; ## [4] &quot;Altitude&quot; &quot;Duration&quot; &quot;Temperature&quot; ## [7] &quot;DOP&quot; &quot;Satellites&quot; &quot;Cause of Fix&quot; ## [10] &quot;CollarSerialNumber&quot; ### add date_time column to both data.frames ---- # Lotek cattle.dat.lotek$date_time = as.POSIXct(cattle.dat.lotek$`GMT Time`, format = &#39;%m/%d/%Y %H:%M:%S %p&#39;, tz = &#39;GMT&#39;) # ATS cattle.dat.ATS$Date = as.Date(cattle.dat.ATS$Julianday, origin = &#39;2021-12-31&#39;) cattle.dat.ATS$date_time = paste(cattle.dat.ATS$Hour, cattle.dat.ATS$Minute, sep = &#39;:&#39;) %&gt;% paste(cattle.dat.ATS$Date, .) %&gt;% as.POSIXct(format = &#39;%Y-%m-%d %H:%M&#39;) ### rename NumSat column ---- cattle.dat.lotek = cattle.dat.lotek %&gt;% rename(NumSats = Satellites) ### add DOP column to ATS cattle.dat.ATS = cattle.dat.ATS %&gt;% mutate(DOP = NA) ### add HDOP column to Lotek cattle.dat.lotek = cattle.dat.lotek %&gt;% mutate(HDOP = NA) ### drop unneeded columns ---- cattle.dat.ATS = cattle.dat.ATS %&gt;% dplyr::select(c(&#39;CollarSerialNumber&#39;, &#39;date_time&#39;, &#39;Latitude&#39;, &#39;Longitude&#39;, &#39;Temperature&#39;, &#39;NumSats&#39;, &#39;DOP&#39;, &#39;HDOP&#39;)) cattle.dat.lotek = cattle.dat.lotek %&gt;% dplyr::select(c(&#39;CollarSerialNumber&#39;, &#39;date_time&#39;, &#39;Latitude&#39;, &#39;Longitude&#39;, &#39;Temperature&#39;, &#39;NumSats&#39;, &#39;DOP&#39;, &#39;HDOP&#39;)) ### create final data.frame ---- cattle.dat = rbind(cattle.dat.ATS, cattle.dat.lotek) %&gt;% mutate(CollarSerialNumber = as.integer(CollarSerialNumber)) 2.5 add cow ear tag and breed info ## read in collar metadata collar.metadata = read.csv(&#39;../cattle/raw data/collar_pedometer-metadata/collar data log.csv&#39;) %&gt;% mutate(download_start = as.POSIXct(download_start, format = &#39;%m/%d/%Y&#39;)) %&gt;% mutate(download_end = as.POSIXct(download_end, format = &#39;%m/%d/%Y&#39;)) %&gt;% rename(CollarSerialNumber = collar.no) collar.metadataS22.S23 = collar.metadata %&gt;% filter(download_end &gt; as.POSIXct(&quot;2021-11-10 MST&quot;)) cattle.dat.tags = left_join(cattle.dat, collar.metadataS22.S23[,1:3]) ## Joining with `by = ## join_by(CollarSerialNumber)` 2.6 clean collar data NOTE: for now, I’m just removing all points with coordinates (0,0). I will need to change this to filter points based on NumSats or DOP/HDOP cattle.dat.tags = cattle.dat.tags %&gt;% filter(Latitude != 0 &amp; Longitude != 0) 2.7 save output to .csv write.csv(cattle.dat.tags, file = &#39;../processed data/2021-2022_GPS-combined.csv&#39;, row.names = F) "],["create-cattle.db-database.html", "Chapter 3 Create cattle.db database 3.1 Description 3.2 create cattle.db file 3.3 import metadata .csv files 3.4 add tag_no column to diet data 3.5 create tables in SQL", " Chapter 3 Create cattle.db database 3.1 Description This code creates a relational database with all of my cattle-related data! Again, the data I have available is listed below: Cow breed and ear tag ID Beef metrics (including weights and body condition scores) Diet sample data Collar deployment dates Collars (including brand and serial number) GPS data (raw from the collars) I will use SQL language to build a database with all these data, allowing me to easily access information of any kind from every individual in my study. 3.2 create cattle.db file cattle_db = dbConnect(RSQLite::SQLite(), &#39;../cattle/cattle.db&#39;) 3.3 import metadata .csv files # cows: old tag, new tag, breed cows = read.csv(&#39;../cattle/raw data/tag-breed-info.csv&#39;) %&gt;% mutate(tag_no = ifelse(new_tag == &#39;&#39;, old_tag, new_tag)) # metrics: date, new tag, weight, bcs metrics = read.csv(&#39;../cattle/raw data/collar_pedometer-metadata/collars.peds_all.csv&#39;) %&gt;% rename(old_tag = tag_no) %&gt;% mutate(tag_no = ifelse(new_tag == &#39;&#39;, old_tag, new_tag)) %&gt;% dplyr::select(date, tag_no, weight, BCS) # diet: collection date, new_tag, tube_id, process date diet = read.csv(&#39;../cattle/raw data/fecal sample ID.csv&#39;) %&gt;% dplyr::select(Collection_Date, Tag, New_Tag, Tube, Processing_Date) %&gt;% rename(old_tag = Tag, new_tag = New_Tag, collection_date = Collection_Date, processing_date = Processing_Date, tube = Tube) %&gt;% filter(tube != &#39;&#39;) # deployments: new_tag, collar_no, download_start, download_end deployments = read.csv(&#39;../cattle/raw data/collar_pedometer-metadata/collar data log.csv&#39;) %&gt;% dplyr::select(tag.no, collar.no, download_start, download_end) %&gt;% rename(tag_no = tag.no, collar_no = collar.no) # collars: collar_no, brand, status collars = read.csv(&#39;../cattle/raw data/collar_pedometer-metadata/collars.csv&#39;) %&gt;% dplyr::select(Serial.No, status, brand) %&gt;% rename(collar_no = Serial.No) # gps_raw: date, collar_no, temp, lat, long, DOP, satellites gps_raw = read.csv(&#39;../cattle/processed data/2021-2022_GPS-combined.csv&#39;) %&gt;% rename(collar_no = CollarSerialNumber, date = date_time) 3.4 add tag_no column to diet data for(i in 1:nrow(diet)){ diet$tag_no[i] = ifelse(diet$new_tag[i] == &#39;&#39;, cows[which(cows$old_tag == diet$old_tag[i]),]$tag_no, diet$new_tag[i]) } 3.5 create tables in SQL 3.5.1 cows # create table dbExecute(cattle_db, &#39;CREATE TABLE cows ( tag_no varchar(4) NOT NULL, old_tag varchar(4), new_tag varchar(4), breed varchar(6), PRIMARY KEY (tag_no));&#39;) # populate table dbWriteTable(cattle_db, &#39;cows&#39;, cows, append = T) dbGetQuery(cattle_db, &#39;SELECT * FROM cows LIMIT 10;&#39;) 3.5.2 metrics # create table dbExecute(cattle_db, &#39;CREATE TABLE metrics ( metric_id INTEGER PRIMARY KEY AUTOINCREMENT, tag_no varchar(4), weight double, BCS double, date text, FOREIGN KEY(tag_no) REFERENCES cows(tag_no));&#39;) # populate table metrics$metric_id = 1:nrow(metrics) metrics = metrics[, c(&#39;metric_id&#39;, &#39;tag_no&#39;, &#39;weight&#39;, &#39;BCS&#39;, &#39;date&#39;)] dbWriteTable(cattle_db, &#39;metrics&#39;, metrics, append = T) dbGetQuery(cattle_db, &#39;SELECT * FROM metrics LIMIT 10;&#39;) 3.5.3 diet # create table dbExecute(cattle_db, &#39;CREATE TABLE diet ( collection_date text, old_tag varchar(4), new_tag varchar(4), tube text, processing_date text, tag_no varchar(4), PRIMARY KEY (tube), FOREIGN KEY (tag_no) REFERENCES cows(tag_no));&#39;) # populate table dbWriteTable(cattle_db, &#39;diet&#39;, diet, append = T) dbGetQuery(cattle_db, &#39;SELECT * FROM diet LIMIT 10;&#39;) 3.5.4 collars # create table dbExecute(cattle_db, &#39;CREATE TABLE collars ( collar_no double, status text, brand text, PRIMARY KEY (collar_no));&#39;) # populate table dbWriteTable(cattle_db, &#39;collars&#39;, collars, append = T) dbGetQuery(cattle_db, &#39;SELECT * FROM collars LIMIT 10;&#39;) 3.5.5 deployments # create table dbExecute(cattle_db, &#39;CREATE TABLE deployments ( deployment_id INTEGER PRIMARY KEY AUTOINCREMENT, tag_no varchar(4), collar_no double, download_start text, download_end text, FOREIGN KEY(tag_no) REFERENCES cows(tag_no) FOREIGN KEY(collar_no) REFERENCES collars(collar_no));&#39;) # populate table deployments$deployment_id = 1:nrow(deployments) deployments = deployments[, c(&#39;deployment_id&#39;, &#39;tag_no&#39;, &#39;collar_no&#39;, &#39;download_start&#39;, &#39;download_end&#39;)] dbWriteTable(cattle_db, &#39;deployments&#39;, deployments, append = T) dbGetQuery(cattle_db, &#39;SELECT * FROM deployments LIMIT 10;&#39;) 3.5.6 gps_raw # create table dbExecute(cattle_db, &#39;CREATE TABLE gps_raw ( fix_id INTEGER PRIMARY KEY AUTOINCREMENT, collar_no integer, date text, Latitude double, Longitude double, Temperature double, NumSats integer, FOREIGN KEY(collar_no) REFERENCES collars(collar_no));&#39;) # populate table gps_raw$fix_id = 1:nrow(gps_raw) gps_raw = gps_raw[, c(&#39;fix_id&#39;, &#39;collar_no&#39;, &#39;date&#39;, &#39;Latitude&#39;, &#39;Longitude&#39;, &#39;Temperature&#39;, &#39;NumSats&#39;)] dbWriteTable(cattle_db, &#39;gps_raw&#39;, gps_raw, append = T) dbGetQuery(cattle_db, &#39;SELECT * FROM gps_raw LIMIT 10;&#39;) 3.5.7 link gps_raw to tag_no # create table dbExecute(cattle_db, &#39;CREATE TABLE gps ( loc_id INTEGER PRIMARY KEY, collar_no integer, tag_no varchar(4), date text, Latitude double, Longitude double, Temperature double, NumSats integer, FOREIGN KEY (collar_no) REFERENCES collars(collar_no) FOREIGN KEY (tag_no) REFERENCES cows(tag_no));&#39;) # insert data into gps table from gps_raw and deployments dbExecute(cattle_db, &#39;INSERT INTO gps ( collar_no, tag_no, date, Latitude, Longitude, Temperature, NumSats) SELECT deployments.collar_no, deployments.tag_no, gps_raw.date, gps_raw.Latitude, gps_raw.Longitude, gps_raw.Temperature, gps_raw.NumSats FROM deployments LEFT JOIN gps_raw USING (collar_no) WHERE gps_raw.collar_no = deployments.collar_no AND ( ( (strftime(gps_raw.date) &gt;= strftime(deployments.download_start)) AND (strftime(gps_raw.date) &lt;= strftime(deployments.download_end)) ) OR ( (strftime(gps_raw.date) &gt;= strftime(deployments.download_start)) AND deployments.download_end IS NULL ) ) &#39;) dbGetQuery(cattle_db, &#39;SELECT * FROM gps LIMIT 10;&#39;) "],["create-heat-maps.html", "Chapter 4 Create heat maps 4.1 Description 4.2 Load in pasture shapefiles 4.3 Read in collar data, reproject to UTM, and convert to sf object 4.4 Calculate activity modes 4.5 Create map of pastures 4.6 Interactive maps of each pasture", " Chapter 4 Create heat maps 4.1 Description I’m curious where the cows are hanging out, and if there is much difference between the areas inhabited by angus vs criollo cows. Before doing any advanced analyses, my first step will be to plot the points from the cows’ GPS collars, overlaid on maps of the pastures in Indian Creek. 4.2 Load in pasture shapefiles cottonwood = read_sf(&quot;./../spatial data/Cottonwood_Allotment_and_pasture_boundaries/Cottonwood_Allotment_and_pasture_boundaries.shp&quot;) indianCreek = read_sf(&quot;./../spatial data/Cottonwood_Allotment_and_pasture_boundaries/BLM_IndianCreekAllotment.shp&quot;) winterUSU = read_sf(&quot;./../spatial data/USU_study_winter_pastures_dissolve/USU_study_winter_pastures_dissolve.shp&quot;) 4.3 Read in collar data, reproject to UTM, and convert to sf object Here I’ll read in the .csv file I created in Chapter 2 that contains all the GPS collar data combined and organized. # read in data cattle.dat = read.csv(&#39;../cattle/processed data/2021-2022_GPS-combined.csv&#39;) # convert to sf object cattle.gps = st_as_sf(cattle.dat, coords = c(&#39;Longitude&#39;, &#39;Latitude&#39;)) st_crs(cattle.gps) = CRS(&quot;+proj=longlat +ellps=WGS84&quot;) # reproject to UTM cattle.gps$geometry = st_transform(cattle.gps$geometry, crs = st_crs(cottonwood)) st_crs(cattle.gps) == st_crs(indianCreek) ## [1] TRUE # convert dates to posixct cattle.gps$date_time = as.POSIXct(cattle.gps$date_time) # convert breed to factor cattle.gps$breed = as.factor(cattle.gps$breed) 4.4 Calculate activity modes Before I make the heatmaps, I’d like to classify the data by activity mode (namely, resting or grazing) based on the movement velocity recorded by the collars. That way, I can see if there there are differences within and between breeds in the areas used for grazing or resting. I don’t care quite so much right now about the areas the cows just travel through, I really just want to know where they’re hanging out. # create and clean cattle.frame cattle.frame = (cattle.gps) %&gt;% filter(!is.na(breed) &amp; !is.na(date_time)) %&gt;% mutate(tag.no = as.factor(tag.no)) %&gt;% distinct() # add x and y coordinates cattle.frame = bind_cols(cattle.frame, as.data.frame(st_coordinates(cattle.frame))) cattle.list = split(cattle.frame, f = cattle.frame$tag.no) # make track cattle.track = lapply(cattle.list, FUN = mk_track, .x = X, .y = Y, .t = date_time, crs = st_crs(cattle.gps), order_by_ts = T, check_duplicates = F) rm(cattle.list) # calculate velocity from track tags = levels(cattle.frame$tag.no) cattle.speed = lapply(cattle.track, FUN = speed) for(i in seq(1:length(tags))){ c = tags[i] cattle.track[[c]][4] = cattle.speed[[c]] names(cattle.track[[c]])[4] = &#39;speed&#39; } # convert list back into data.frame speed.frame = list.rbind(cattle.track) temp = array() for(i in seq(1:length(tags))){ temp = append(temp, rep(tags[i], times = dim(cattle.track[[i]])[1])) } temp = temp[!is.na(temp)] speed.frame = speed.frame %&gt;% mutate(tag.no = temp) %&gt;% rename(X = x_, Y = y_, date_time = t_) rm(cattle.track) # merge cattle.frame and speed.frame cattle.frame = merge(cattle.frame, speed.frame[,3:5], by = c(&#39;tag.no&#39;,&#39;date_time&#39;)) # classify activity based on speed (from Nyamuryekung&#39;e et al. 2021a) resting = 2.34/60 # max resting speed in m/s grazing = 25/60 # max grazing speed in m/s cattle.frame = cattle.frame %&gt;% mutate(activity = case_when(speed &lt;= resting ~ &#39;resting&#39;, speed &gt; resting &amp; speed &lt;= grazing ~ &#39;grazing&#39;, speed &gt; grazing ~ &#39;traveling&#39;, T ~ &#39;none&#39;)) cattle.grazing = cattle.frame %&gt;% filter(activity == &#39;grazing&#39;) cattle.resting = cattle.frame %&gt;% filter(activity == &#39;resting&#39;) 4.5 Create map of pastures The cattle rotate through several pastures in Indian Creek from October through May. This map shows roughly which months the cows were in each pasture in 2022. 4.6 Interactive maps of each pasture In this section, I have created Leaflet maps of each pasture. Feel free to zoom in and out in each map! 4.6.1 Park Pasture # Activity mode = resting park.map.resting # Activity mode = grazing park.map.grazing 4.6.2 Creek Pasture # Activity mode = resting creek.map.resting # Activity mode = grazing creek.map.grazing 4.6.3 Drill Pasture # Activity mode = resting drill.map.resting # Activity mode = grazing drill.map.grazing 4.6.4 Davis and Lavender Canyons # Activity mode = resting davis.lav.map.resting # Activity mode = grazing davis.lav.map.grazing 4.6.5 Corral Pocket # Activity mode = resting corral.map.resting # Activity mode = grazing corral.map.grazing "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
